// Copyright 2016 - 2019 The excelize Authors. All rights reserved. Use of
// this source code is governed by a BSD-style license that can be found in
// the LICENSE file.
//
// Package excelize providing a set of functions that allow you to write to
// and read from XLSX files. Support reads and writes XLSX file generated by
// Microsoft Excelâ„¢ 2007 and later. Support save file without losing original
// charts of XLSX. This library needs Go version 1.10 or later.

package excelize

import (
	"bytes"
	"encoding/xml"
	"errors"
	"fmt"
	"io/ioutil"
	"os"
	"reflect"
	"strconv"
	"strings"
	"time"
)

// StreamWriter defined the type of stream writer.
type StreamWriter struct {
	tmpFile    *os.File
	File       *File
	Sheet      string
	SheetID    int
	SheetData  bytes.Buffer
	encoder    *xml.Encoder
	table      *xlsxTable
	replaceMap map[string][]byte
}

// NewStreamWriter return stream writer struct by given worksheet name for
// generate new worksheet with large amounts of data. Note that after set
// rows, you must call the 'Flush' method to end the streaming writing
// process and ensure that the order of line numbers is ascending. For
// example, set data for worksheet of size 102400 rows x 50 columns with
// numbers:
//
//    file := excelize.NewFile()
//    streamWriter, err := file.NewStreamWriter("Sheet1")
//    if err != nil {
//        panic(err)
//    }
//    for rowID := 1; rowID <= 102400; rowID++ {
//        row := make([]interface{}, 50)
//        for colID := 0; colID < 50; colID++ {
//            row[colID] = rand.Intn(640000)
//        }
//        cell, _ := excelize.CoordinatesToCellName(1, rowID)
//        if err := streamWriter.SetRow(cell, row, nil); err != nil {
//            panic(err)
//        }
//    }
//    if err := streamWriter.Flush(); err != nil {
//        panic(err)
//    }
//    if err := file.SaveAs("Book1.xlsx"); err != nil {
//        panic(err)
//    }
//
func (f *File) NewStreamWriter(sheet string) (*StreamWriter, error) {
	sheetID := f.GetSheetIndex(sheet)
	if sheetID == 0 {
		return nil, fmt.Errorf("sheet %s is not exist", sheet)
	}
	rsw := &StreamWriter{
		File:    f,
		Sheet:   sheet,
		SheetID: sheetID,
		replaceMap: map[string][]byte{
			"XMLName": []byte{},
		},
	}
	rsw.encoder = xml.NewEncoder(&rsw.SheetData)
	rsw.SheetData.WriteString("<sheetData>")
	return rsw, nil
}

// SetTable creates an Excel table for the StreamWriter. This function must be
// called before the first SetRow.
//
// The first SetRow will create the column names. These Column names must be
// strings or an error will be returned.
func (sw *StreamWriter) SetTable(format string) error {
	formatSet, err := parseFormatTableSet(format)
	if err != nil {
		return err
	}

	tableID := sw.File.countTables() + 1

	name := formatSet.TableName
	if name == "" {
		name = "Table" + strconv.Itoa(tableID)
	}

	sw.table = &xlsxTable{
		XMLNS:       NameSpaceSpreadSheet,
		ID:          tableID,
		Name:        name,
		DisplayName: name,
		TableStyleInfo: &xlsxTableStyleInfo{
			Name:              formatSet.TableStyle,
			ShowFirstColumn:   formatSet.ShowFirstColumn,
			ShowLastColumn:    formatSet.ShowLastColumn,
			ShowRowStripes:    formatSet.ShowRowStripes,
			ShowColumnStripes: formatSet.ShowColumnStripes,
		},
	}
	return nil
}

// SetRow writes an array to stream rows by giving a worksheet name, starting
// coordinate and a pointer to an array of values. If styles is non-nil, then
// the styles must be the same size as the values and will be applied to each
// corresponding cell. Note that you must call the 'Flush' method to end the
// streaming writing process.
func (sw *StreamWriter) SetRow(axis string, values []interface{}, styles []int) error {
	col, row, err := CellNameToCoordinates(axis)
	if err != nil {
		return err
	}

	if styles == nil {
		styles = make([]int, len(values))
	}
	if len(styles) != len(values) {
		return errors.New("incorrect number of styles for this row")
	}

	if sw.table != nil {
		if sw.table.TableColumns == nil {
			// create table columns using the first row
			tableColumn := make([]*xlsxTableColumn, len(values))
			sw.table.TableColumns = &xlsxTableColumns{
				Count:       len(tableColumn),
				TableColumn: tableColumn,
			}

			nameUsed := map[string]bool{}
			for i, v := range values {
				v, ok := v.(string)
				if !ok {
					return fmt.Errorf("column header %d is not a string", i+1)
				}

				// if column names are duplicated, do the same thing that Excel
				// does and append a number
				name := v
				if name != "" {
					for count := 1; nameUsed[name]; count++ {
						name = fmt.Sprintf("%s%d", name, count+1)
					}
					nameUsed[name] = true
				}

				tableColumn[i] = &xlsxTableColumn{
					ID:   i + 1,
					Name: name,
				}
			}
			idx := 1
			for _, c := range tableColumn {
				if c.Name == "" {
					c.Name = fmt.Sprintf("Column%d", idx)
					for ; nameUsed[c.Name]; idx++ {
						c.Name = fmt.Sprintf("Column%d", idx)
					}
					nameUsed[c.Name] = true
				}
			}

			ref, err := sw.File.coordinatesToAreaRef([]int{col, row, col + len(values) - 1, row})
			if err != nil {
				return err
			}
			sw.table.Ref = ref
			sw.table.AutoFilter = &xlsxAutoFilter{Ref: ref}
		} else {
			c, err := sw.File.areaRefToCoordinates(sw.table.Ref)
			if err != nil {
				return err
			}
			if col != c[0] || col+sw.table.TableColumns.Count != c[2]+1 || row <= c[3] {
				return fmt.Errorf("row %d is outside the table bounds", row+1)
			}
			c[3] = row

			ref, err := sw.File.coordinatesToAreaRef(c)
			if err != nil {
				return err
			}
			sw.table.Ref = ref
			sw.table.AutoFilter.Ref = ref
		}
	}

	sw.SheetData.WriteString(fmt.Sprintf(`<row r="%d">`, row))
	for i, val := range values {
		axis, err := CoordinatesToCellName(col+i, row)
		if err != nil {
			return err
		}
		c := xlsxC{R: axis, S: styles[i]}
		switch val := val.(type) {
		case int:
			c.T, c.V = setCellInt(val)
		case int8:
			c.T, c.V = setCellInt(int(val))
		case int16:
			c.T, c.V = setCellInt(int(val))
		case int32:
			c.T, c.V = setCellInt(int(val))
		case int64:
			c.T, c.V = setCellInt(int(val))
		case uint:
			c.T, c.V = setCellInt(int(val))
		case uint8:
			c.T, c.V = setCellInt(int(val))
		case uint16:
			c.T, c.V = setCellInt(int(val))
		case uint32:
			c.T, c.V = setCellInt(int(val))
		case uint64:
			c.T, c.V = setCellInt(int(val))
		case float32:
			c.T, c.V = setCellFloat(float64(val), -1, 32)
		case float64:
			c.T, c.V = setCellFloat(val, -1, 64)
		case string:
			c.T, c.V, c.XMLSpace = setCellStr(val)
		case []byte:
			c.T, c.V, c.XMLSpace = setCellStr(string(val))
		case time.Duration:
			c.T, c.V = setCellDuration(val)
		case time.Time:
			c.T, c.V, _, err = setCellTime(val)
		case bool:
			c.T, c.V = setCellBool(val)
		case nil:
			c.T, c.V, c.XMLSpace = setCellStr("")
		default:
			c.T, c.V, c.XMLSpace = setCellStr(fmt.Sprint(val))
		}
		sw.encoder.Encode(c)
	}
	sw.SheetData.WriteString(`</row>`)
	// Try to use local storage
	chunk := 1 << 24
	if sw.SheetData.Len() >= chunk {
		if sw.tmpFile == nil {
			err := sw.createTmp()
			if err != nil {
				// can not use local storage
				return nil
			}
		}
		// use local storage
		_, err := sw.tmpFile.Write(sw.SheetData.Bytes())
		if err != nil {
			return nil
		}
		sw.SheetData.Reset()
	}
	return err
}

// Flush ending the streaming writing process.
func (sw *StreamWriter) Flush() error {
	sw.SheetData.WriteString(`</sheetData>`)

	ws, err := sw.File.workSheetReader(sw.Sheet)
	if err != nil {
		return err
	}
	sheetXML := fmt.Sprintf("xl/worksheets/sheet%d.xml", sw.SheetID)
	delete(sw.File.Sheet, sheetXML)
	delete(sw.File.checked, sheetXML)
	var sheetDataByte []byte
	if sw.tmpFile != nil {
		// close the local storage file
		if err = sw.tmpFile.Close(); err != nil {
			return err
		}

		file, err := os.Open(sw.tmpFile.Name())
		if err != nil {
			return err
		}

		sheetDataByte, err = ioutil.ReadAll(file)
		if err != nil {
			return err
		}

		if err := file.Close(); err != nil {
			return err
		}

		err = os.Remove(sw.tmpFile.Name())
		if err != nil {
			return err
		}
	}

	sheetDataByte = append(sheetDataByte, sw.SheetData.Bytes()...)
	sw.replaceMap["SheetData"] = sheetDataByte
	sw.SheetData.Reset()

	if sw.table != nil {
		tableID := sw.File.countTables() + 1
		sheetRelationshipsTableXML := "../tables/table" + strconv.Itoa(tableID) + ".xml"
		tableXML := strings.Replace(sheetRelationshipsTableXML, "..", "xl", -1)

		// Add first table for given sheet.
		sheetPath, _ := sw.File.sheetMap[trimSheetName(sw.Sheet)]
		sheetRels := "xl/worksheets/_rels/" + strings.TrimPrefix(sheetPath, "xl/worksheets/") + ".rels"
		rID := sw.File.addRels(sheetRels, SourceRelationshipTable, sheetRelationshipsTableXML, "")

		tableParts := fmt.Sprintf(`<tableParts count="1"><tablePart r:id="rId%d"></tablePart></tableParts>`, rID)
		sw.replaceMap["TableParts"] = []byte(tableParts)

		sw.File.addContentTypePart(tableID, "table")

		table, _ := xml.Marshal(sw.table)
		sw.File.saveFileList(tableXML, table)
	}

	sw.File.XLSX[fmt.Sprintf("xl/worksheets/sheet%d.xml", sw.SheetID)] =
		bulkUpdateSheet(ws, sw.replaceMap)
	return err
}

// createTmp creates a temporary file in the operating system default
// temporary directory.
func (sw *StreamWriter) createTmp() (err error) {
	sw.tmpFile, err = ioutil.TempFile(os.TempDir(), "excelize-")
	return err
}

// bulkUpdateSheet provides method to bulk-replace fields in a worksheet.
func bulkUpdateSheet(ws *xlsxWorksheet, replaceMap map[string][]byte) []byte {
	s := reflect.ValueOf(ws).Elem()
	typeOfT := s.Type()
	var marshalResult []byte
	marshalResult = append(marshalResult, []byte(XMLHeader+`<worksheet`+templateNamespaceIDMap)...)
	for i := 0; i < s.NumField(); i++ {
		f := s.Field(i)
		content, ok := replaceMap[typeOfT.Field(i).Name]
		if ok {
			marshalResult = append(marshalResult, content...)
			continue
		}
		out, _ := xml.Marshal(f.Interface())
		marshalResult = append(marshalResult, out...)
	}
	marshalResult = append(marshalResult, []byte(`</worksheet>`)...)
	return marshalResult
}
